---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.2
  kernelspec:
    display_name: Python [Root]
    language: python
    name: Python [Root]
---

We need to execute the *ipython* magic twice.  We do not know why.  Once is not enough.  If you add a comment before the *ipython* magic, even twice is not enough.

```{python}
from scipy import *
import numpy as np
from numpy.random import rand, uniform
import matplotlib.pyplot as plt
import matplotlib.animation
import PlanktonSignaling.basics as PS
import PlanktonSignaling.BlobDetection as BD
import PlanktonSignaling.Deposition as DP
import profile
import time
import copy

# %matplotlib notebook
# %matplotlib notebook

# #%load_ext Cython
```

Note here that $d_1 = \frac{\kappa \lambda_0}{v^2}$ and $d_2 = \frac{\beta}{\lambda_0}$. For the correct deposition functions, use linAtanDep2 and atanDep2 to include tanh.

```{python}
meshsize = 20
numb = 30**2 #must be a perfect square.
LL = 10

Swimmers = PS.Plankton(DP.constantDep,d1=0.2,d2=5,N = meshsize,depMaxStr=.01,
                           Const=3,L=LL,k=0.02,epsilon=1e-3,depThreshold=0.05, 
                           depTransWidth=0.03, num = numb, c0=0.012)

def initial_conditions(x,y):
    return(0*x+Swimmers.c0)

print(Swimmers.d1)
print(Swimmers.d2)
Swimmers.CheckStability()
```

```{python}
def particleProjection(pos,meshsize):
    
    x = r_[0:Swimmers.L:1j*meshsize]# setup the spatial mesh. It is a long row vector
    # Create some local coordinates for the square domain.
    y = 1*x
    xm,ym = np.meshgrid(x,y)
    f = np.zeros((meshsize,meshsize))
    Std = Swimmers.depVar
    boundaryCutoff = 64*Std
    for i in range(0,Swimmers.num):
        A, B, C, D = 0,0,0,0
        
        p = pos[i,:]
        
        f = f + (1/(4*pi*Std))*np.exp(-((xm-p[0])**2+(ym-p[1])**2)/4/Std)
        
        if ((p[0])**2<boundaryCutoff):
            f = f + (1/(4*pi*Std))*np.exp(-((xm-p[0]-Swimmers.L)**2+(ym-p[1])**2)/4/Std)
            A = 1
        if ((p[0]-Swimmers.L)**2<boundaryCutoff):
            f = f + (1/(4*pi*Std))*np.exp(-((xm-p[0]+Swimmers.L)**2+(ym-p[1])**2)/4/Std)
            B = 1
        if ((p[1])**2<boundaryCutoff):
            f = f + (1/(4*pi*Std))*np.exp(-((xm-p[0])**2+(ym-p[1]-Swimmers.L)**2)/4/Std)
            C = 1
        if ((p[1]-Swimmers.L)**2<boundaryCutoff):
            f = f + (1/(4*pi*Std))*np.exp(-((xm-p[0])**2+(ym-p[1]+Swimmers.L)**2)/4/Std)
            D = 1
            
        if ((A == 1) and (C == 1)): #Plankton in Lower Left Corner
            f = f + (1/(4*pi*Std))*np.exp(-((xm-p[0]-Swimmers.L)**2+(ym-p[1]-Swimmers.L)**2)/4/Std)
        if ((A == 1) and (D == 1)): #Plankton in Upper Left Corner
            f = f + (1/(4*pi*Std))*np.exp(-((xm-p[0]-Swimmers.L)**2+(ym-p[1]+Swimmers.L)**2)/4/Std)
        if ((B == 1) and (C == 1)): #Plankton in Lower Right Corner
            f = f + (1/(4*pi*Std))*np.exp(-((xm-p[0]+Swimmers.L)**2+(ym-p[1]-Swimmers.L)**2)/4/Std)
        if ((B == 1) and (D == 1)): #Plankton in Upper Right Corner
            f = f + (1/(4*pi*Std))*np.exp(-((xm-p[0]+Swimmers.L)**2+(ym-p[1]+Swimmers.L)**2)/4/Std)
            
    return xm,ym,f*(Swimmers.density*Swimmers.L**2/Swimmers.num)


def particleProjectionFaster(pos,meshsize):
    
    x = r_[0:Swimmers.L:1j*meshsize] # setup the spatial mesh. It is a long row vector
    # Create some local coordinates for the square domain.
    y = 1*x
    xm,ym = np.meshgrid(x,y)
    f = np.zeros((meshsize,meshsize))
    Std = Swimmers.depVar

    boundaryCutoff = 64*Std
    
    intDelta = int((meshsize)*8*np.sqrt(Std)/Swimmers.L + 0.5)
    
    for i in range(0,Swimmers.num):
        A, B, C, D = 0,0,0,0
        p = pos[i,:]
        
        centerX = int((meshsize-1)*p[0]/Swimmers.L+0.5)
        centerY = int((meshsize-1)*p[1]/Swimmers.L+0.5)
        
        lowerX      = max(0,centerX-intDelta)
        lowerXplus  = max(0,centerX-intDelta + (meshsize-1))
        lowerXminus = max(0,centerX-intDelta - (meshsize-1))
        upperX      = min(meshsize,centerX+intDelta)
        upperXplus  = min(meshsize,centerX+intDelta + (meshsize-1))
        upperXminus = min(meshsize,centerX+intDelta - (meshsize-1))
        lowerY      = max(0,centerY-intDelta)
        lowerYplus  = max(0,centerY-intDelta + (meshsize-1))
        lowerYminus = max(0,centerY-intDelta - (meshsize-1))
        upperY      = min(meshsize,centerY+intDelta)
        upperYplus  = min(meshsize,centerY+intDelta + (meshsize-1))
        upperYminus = min(meshsize,centerY+intDelta - (meshsize-1))
        
        sliceX = slice(lowerX,upperX+1)
        sliceY = slice(lowerY,upperY+1)
        
        f[sliceY,sliceX] = f[sliceY,sliceX] + (1/(4*pi*Std))*np.exp(-((xm[sliceY,sliceX]-p[0])**2+(ym[sliceY,sliceX]-p[1])**2)/4/Std)
        if ((p[0])**2<boundaryCutoff):
            sliceX = slice(lowerXplus,upperXplus+1)
            sliceY = slice(lowerY,upperY+1)
            f[sliceY,sliceX] = f[sliceY,sliceX] + (1/(4*pi*Std))*np.exp(-((xm[sliceY,sliceX]-p[0]-Swimmers.L)**2+(ym[sliceY,sliceX]-p[1])**2)/4/Std)
            A = 1
        if ((p[0]-Swimmers.L)**2<boundaryCutoff):
            sliceX = slice(lowerXminus,upperXminus+1)
            sliceY = slice(lowerY,upperY+1)
            f[sliceY,sliceX] = f[sliceY,sliceX] + (1/(4*pi*Std))*np.exp(-((xm[sliceY,sliceX]-p[0]+Swimmers.L)**2+(ym[sliceY,sliceX]-p[1])**2)/4/Std)
            B = 1
        if ((p[1])**2<boundaryCutoff):
            sliceX = slice(lowerX,upperX+1)
            sliceY = slice(lowerYplus,upperYplus+1)
            f[sliceY,sliceX] = f[sliceY,sliceX] + (1/(4*pi*Std))*np.exp(-((xm[sliceY,sliceX]-p[0])**2+(ym[sliceY,sliceX]-p[1]-Swimmers.L)**2)/4/Std)
            C = 1
        if ((p[1]-Swimmers.L)**2<boundaryCutoff):
            sliceX = slice(lowerX,upperX+1)
            sliceY = slice(lowerYminus,upperYminus+1)
            f[sliceY,sliceX] = f[sliceY,sliceX] + (1/(4*pi*Std))*np.exp(-((xm[sliceY,sliceX]-p[0])**2+(ym[sliceY,sliceX]-p[1]+Swimmers.L)**2)/4/Std)
            D = 1
        if (A == 1 and C == 1): #Plankton in Lower Left Corner
            sliceX = slice(lowerXplus,upperXplus+1)
            sliceY = slice(lowerYplus,upperYplus+1)
            f[sliceY,sliceX] = f[sliceY,sliceX] + (1/(4*pi*Std))*np.exp(-((xm[sliceY,sliceX]-p[0]-Swimmers.L)**2+(ym[sliceY,sliceX]-p[1]-Swimmers.L)**2)/4/Std)
        if (A == 1 and D == 1): #Plankton in Lower Left Corner
            sliceX = slice(lowerXplus,upperXplus+1)
            sliceY = slice(lowerYminus,upperYminus+1)
            f[sliceY,sliceX] = f[sliceY,sliceX] + (1/(4*pi*Std))*np.exp(-((xm[sliceY,sliceX]-p[0]-Swimmers.L)**2+(ym[sliceY,sliceX]-p[1]+Swimmers.L)**2)/4/Std)
        if (B == 1 and C == 1): #Plankton in Upper Right Corner
            sliceX = slice(lowerXminus,upperXminus+1)
            sliceY = slice(lowerYplus,upperYplus+1)
            f[sliceY,sliceX] = f[sliceY,sliceX] + (1/(4*pi*Std))*np.exp(-((xm[sliceY,sliceX]-p[0]+Swimmers.L)**2+(ym[sliceY,sliceX]-p[1]-Swimmers.L)**2)/4/Std)
        if (B == 1 and D == 1): #Plankton in Lower Right Corner
            sliceX = slice(lowerXminus,upperXminus+1)
            sliceY = slice(lowerYminus,upperYminus+1)
            f[sliceY,sliceX] = f[sliceY,sliceX] + (1/(4*pi*Std))*np.exp(-((xm[sliceY,sliceX]-p[0]+Swimmers.L)**2+(ym[sliceY,sliceX]-p[1]+Swimmers.L)**2)/4/Std)
    return xm,ym,f*(Swimmers.density*Swimmers.L**2/Swimmers.num)
```

```{python}
# %matplotlib notebook

Swimmers.SetIC(initial_conditions)

#Fixed the initialization here
pos = np.zeros((1,2))

lenn= int(np.sqrt(numb))
th = rand()*2*pi
vel = np.zeros((1,2))

for l in range(0,lenn):
    for k in range(0,lenn):
        #To include randomness, comment out this line
        #pos = np.append(pos,[np.array([np.mod(k*(Swimmers.L*1/lenn) + 0.01*(rand()-0.5) + 0.5*(Swimmers.L*1/lenn),Swimmers.L),
                                  #np.mod(l*(Swimmers.L*1/lenn) + 0.01*(rand()-0.5) + 0.5*(Swimmers.L*1/lenn),Swimmers.L)])],axis=0)
        pos = np.append(pos,[np.array([np.mod(k*(Swimmers.L*1/(lenn+1)) + 0.5*(Swimmers.L*1/(lenn+1)),Swimmers.L),
                                  np.mod(l*(Swimmers.L*1/(lenn+1)) + 0.5*(Swimmers.L*1/(lenn+1)),Swimmers.L)])],axis=0)
        th  = rand()*2*pi
        vel = np.append(vel,[np.array([np.cos(th),np.sin(th)])],axis=0)
pos = np.delete(pos,0,0)
vel = np.delete(vel,0,0)

plt.figure()
#plt.pcolormesh(Swimmers.xm,Swimmers.ym,Swimmers.Meshed())
plt.plot(pos[:,0],pos[:,1],'r.',MarkerSize=.4)
plt.show()
```

### Testing For Error Here

```{python}
pos_store = list([pos[:,:]])
pos_store = list([np.array(pos)])

scalar_store = list([Swimmers.Meshed()])

#start = time.process_time()
particleMeshsize = Swimmers.N

xm, ym, ContoursReg = particleProjection(pos_store[0],particleMeshsize)
xm, ym, ContoursSlice = particleProjectionFaster(pos_store[0],particleMeshsize)

relErr = (np.sum(ContoursSlice) - np.sum(ContoursReg))/np.sum(ContoursReg)
print('Relative Error for Sum: {0}'.format(relErr))
```

```{python}
plt.figure()
plt.pcolormesh(xm,ym,ContoursReg-ContoursSlice)
plt.colorbar()
plt.title(r'Err between Slicing and Regular Update')
```

### Testing Update Methods more Formally

```{python}
NUMB = [5]
plt.figure()
for nn in NUMB:
    meshsize = 200
    numb = nn**2 #must be a perfect square.
    LL = 10
    Swimmers = PS.Plankton(DP.atanDep2,d1=1,d2=20,N = meshsize,depMaxStr=.01,
                           Const=3,L=LL,k=0.02,epsilon=1e-3,depThreshold=0.05, 
                           depTransWidth=0.03, num = numb, c0=0.012)

    def initial_conditions(x,y):
        return(0*x+Swimmers.c0)
    
    simTime = 10

    Swimmers.SetIC(initial_conditions)
    lenn = int(np.sqrt(numb))
    pos = np.zeros((1,2))
    vel = np.zeros((1,2))
    
    for l in range(0,lenn):
        for k in range(0,lenn):
            pos = np.append(pos,[np.array([np.mod(k*(Swimmers.L*1/(lenn)) + 0.5*(Swimmers.L*1/(lenn)),Swimmers.L),
                                            np.mod(l*(Swimmers.L*1/(lenn)) + 0.5*(Swimmers.L*1/(lenn)),Swimmers.L)])],axis=0)
            th  = rand()*2*pi
            vel = np.append(vel,[np.array([np.cos(th),np.sin(th)])],axis=0)
            
            
    pos = np.delete(pos,0,0)
    vel = np.delete(vel,0,0)
    pos_store = list([pos[:,:]])
    pos_store = list([np.array(pos)])
    scalar_store = list([Swimmers.Meshed()])
    
    
    for plot in range(0,1):
        for k in range(0,simTime):
            Swimmers.UpdateSlice(Swimmers.scalar,pos,vel)
            pos_store.append(np.array(pos))
            scalar_store.append(Swimmers.Meshed())
            
    ChemStoreReg = np.empty_like(scalar_store)
    ChemStoreReg[:,:,:] = scalar_store
    
    Swimmers2 = PS.Plankton(DP.atanDep2,d1=1,d2=2,N = meshsize,depMaxStr=.01,
                           Const=3,L=LL,k=0.02,epsilon=1e-3,depThreshold=0.05, 
                           depTransWidth=0.03, num = numb, c0=0.012)

    
    Swimmers2.SetIC(initial_conditions)
    
    pos2 = np.zeros((1,2))
    vel2 = np.zeros((1,2))
    for l in range(0,lenn):
        for k in range(0,lenn):
            pos2 = np.append(pos2,[np.array([np.mod(k*(Swimmers2.L*1/(lenn)) + 0.5*(Swimmers2.L*1/(lenn)),Swimmers2.L),
                                            np.mod(l*(Swimmers2.L*1/(lenn)) + 0.5*(Swimmers2.L*1/(lenn)),Swimmers2.L)])],axis=0)
            th  = rand()*2*pi
            vel2 = np.append(vel2,[np.array([np.cos(th),np.sin(th)])],axis=0)
            
    pos2 = np.delete(pos2,0,0)
    vel2 = np.delete(vel2,0,0)
    pos_store2 = list([pos2[:,:]])
    pos_store2 = list([np.array(pos2)])
    scalar_store2 = list([Swimmers2.Meshed()])
    count = 1
    
    for plot in range(0,1):
        for k in range(0,simTime):
            Swimmers2.UpdateSlice(Swimmers2.scalar,pos2,vel2)
            pos_store2.append(np.array(pos2))
            scalar_store2.append(Swimmers2.Meshed())
            
    ChemStoreSlice = np.empty_like(scalar_store2)
    ChemStoreSlice[:,:,:] = scalar_store2
    
    ERR = []
    for j in range(0,simTime+1):
        ERR = np.append(ERR,(np.sum(ChemStoreSlice[j,:,:])-np.sum(ChemStoreReg[j,:,:]))/np.sum(ChemStoreReg[j,:,:]))
    plt.plot(range(0,simTime+1),ERR,label='N = {0}'.format(nn))
    
plt.title('Changing N affect on Error')
plt.xlabel('Time')
plt.ylabel('Error')
plt.legend()
```

```{python}
plt.figure()
ERR = []
ERR2 = []
for j in range(0,simTime+1):
    ERR = np.append(ERR,np.sum(scalar_store[j]))
    ERR2 = np.append(ERR2,np.sum(scalar_store2[j]))
plt.plot(range(0,simTime+1),ERR,label='N = {0}'.format(nn),color='k')
#plt.plot(range(0,simTime+1),ERR2,label='N = {0}'.format(nn),color='b')
```

```{python}
# %matplotlib notebook

plt.figure()
j = 20
plt.plot(pos_store[j][:,0],pos_store[j][:,1],'ro')
plt.pcolormesh(Swimmers.xm,Swimmers.ym,ChemStoreReg[j,:,:])
plt.colorbar()
plt.title(r'Err between Slicing and Regular Update')
```

```{python}
# %matplotlib notebook

plt.figure()
j = 1
#plt.plot(pos_store[j][:,0],pos_store[j][:,1],'ro')
plt.pcolormesh(Swimmers.xm,Swimmers.ym,ChemStoreReg[j,:,:])
plt.colorbar()
plt.clim(0.011999,0.012001)
plt.title(r'Err between Slicing and Regular Update')
```

```{python}
#Slice update

Swimmers.SetIC(initial_conditions)
pos = np.zeros((1,2))
vel = np.zeros((1,2))

for l in range(0,lenn):
    for k in range(0,lenn):
        pos = np.append(pos,[np.array([np.mod(k*(Swimmers.L*1/(lenn+1)) + 0.5*(Swimmers.L*1/(lenn+1)),Swimmers.L),
                                        np.mod(l*(Swimmers.L*1/(lenn+1)) + 0.5*(Swimmers.L*1/(lenn+1)),Swimmers.L)])],axis=0)
        th  = rand()*2*pi
        vel = np.append(vel,[np.array([np.cos(th),np.sin(th)])],axis=0)
pos = np.delete(pos,0,0)
vel = np.delete(vel,0,0)

pos_store = list([pos[:,:]])
pos_store = list([np.array(pos)])

scalar_store2 = list([Swimmers.Meshed()])

count = 1
for plot in range(0,1):
    for k in range(0,simTime):
        Swimmers.UpdateSlice(Swimmers.scalar,pos,vel)
        pos_store.append(np.array(pos))
        scalar_store2.append(Swimmers.Meshed())
        
ChemStoreSlice = np.empty_like(scalar_store2)
ChemStoreSlice[:,:,:] = scalar_store2
```

### Extra Testing

```{python}
simTime = 10

pos_store = list([pos[:,:]])
pos_store = list([np.array(pos)])

scalar_store = list([Swimmers.Meshed()])
aggreg = np.array([0,0])

count = 1
for plot in range(0,1):
    for k in range(0,simTime):
        Swimmers.Update(Swimmers.scalar,pos,vel)
        pos_store.append(np.array(pos))
        scalar_store.append(Swimmers.Meshed())
        
        #Counts the Number of Aggregations at time k
        
        #aggreg = np.vstack((aggreg,[k+1,BD.countingAll(1,255,BD.Contour(Swimmers,pos,400,meshsize))])) 
#np.save('PlanktonPos',pos_store)
#np.save('ChemStore',scalar_store)
```

```{python}
ERR = []
for j in range(0,simTime+1):
    ERR = np.append(ERR,(np.sum(ChemStoreSlice[j,:,:])-np.sum(ChemStoreReg[j,:,:]))/np.sum(ChemStoreReg[j,:,:]))
plt.figure()
plt.plot(range(0,simTime+1),ERR)
```

```{python}
start = time.process_time()
ContoursAll = np.zeros((len(pos_store),particleMeshsize,particleMeshsize))
for k in range(0,len(scalar_store)):
    xm, ym, ContoursAll[k,:,:] = particleProjection(pos_store[k],particleMeshsize)
#np.save('Contours', ContoursAll)
print('Time: ',time.process_time()-start)
```

```{python}
start = time.process_time()
ContoursAll2 = np.zeros((len(pos_store),particleMeshsize,particleMeshsize))
for k in range(0,len(scalar_store)):
    xm, ym, ContoursAll2[k,:,:] = particleProjectionFaster(pos_store[k],particleMeshsize)
#np.save('Contours', ContoursAll)
print('Time: ',time.process_time()-start)
print('Rel err: ',amax(abs(ContoursAll[0,:,:]-ContoursAll2[0,:,:]))/amax(abs(ContoursAll[0,:,:])))
```

### Snapshot of initial plankton density

```{python}
pos = pos_store[0]
plt.figure()
plt.pcolormesh(xm,ym,ContoursAll[0,:,:])
plt.plot(pos[:,0],pos[:,1],'ro',MarkerSize=.75)
plt.colorbar()
#plt.clim([6,7])
plt.show()
```

# Animations


### Basic Animation with Chemical and Plankton Combined

```{python}
fig   = plt.figure()
ax    = plt.subplot(1,1,1)
pos_store2 = np.load('PlankDots.npy')
scalar_store2 = np.load('ChemStore.npy')
field = ax.pcolormesh(Swimmers.xm,Swimmers.ym,scalar_store2[0])
field.set_clim(0.01199,0.01201)
dots, = ax.plot([], [], 'r.',MarkerSize=.55)
fig.colorbar(field)

plt.suptitle(r'$d_1 = {0},d_2={1}$'.format(Swimmers.d1, Swimmers.d2), fontsize = 10)

def initit():
    dots.set_data([], [])
    return field,dots

def animate(k):
    arr = scalar_store2[k]
    arr = arr[:-1, :-1]
    field.set_array(arr.ravel())
    plt.title(r'Time = ${0}$'.format(k*Swimmers.k), fontsize = 20)
    dots.set_data(pos_store2[k][:,0],pos_store2[k][:,1])

    return dots,field
    
anim = matplotlib.animation.FuncAnimation(fig,animate,frames=range(0,2,1),
                                          interval=400,blit=False,repeat=False)

# Uncomment if you want to save it to a file.  Requires mencoder or ffmpeg or some writer utility to generate the file.
#anim.save('d102_d5_delta1e3_Atandep_HighDensity_scalingsmall3.mp4', writer='ffmpeg')
plt.show()
```

### Animation for Plankton Aggregation Contours

```{python}
fig  = plt.figure()
#SA = (4*pi*Swimmers.L**2*Swimmers.density/Swimmers.num)**2/160000
#pos_store2 = np.load('PlankDots.npy')
#scalar_store2 = np.load('ChemStore.npy')
field1 = plt.pcolormesh(xm,ym,ContoursAll[0,:,:])
fig.colorbar(field1)
#field1.set_clim(0.00042,0.00058)

def initit():
    
    return field1

def animate(k):
    arr2 = ContoursAll[k,:,:]
    arr2 = arr2[:-1,:-1]
    field1.set_array(arr2.ravel())
    plt.suptitle(r'$d_1 = {0},d_2={1}$, Time = ${2}$'.format(Swimmers.d1, Swimmers.d2,round(k*Swimmers.k,2)), fontsize = 20)
    return field1,
    
anim = matplotlib.animation.FuncAnimation(fig,animate,frames=range(0,30,1),
                                          interval=80,blit=False,repeat=False)

# Uncomment if you want to save it to a file.  Requires mencoder or ffmpeg or some writer utility to generate the file.
#anim.save('d102_d5_delta1e3_Atandep_Contours.mp4', writer='ffmpeg')
plt.show()
```

### Animation for finding the most unstable wave numbers using a 2D Fast Fourier Transform

```{python}
fig   = plt.figure()
cmap = plt.get_cmap('binary')
freq = (len(Swimmers.xm)*2*pi/(Swimmers.L))*fftfreq(len(Swimmers.xm))
ax    = plt.subplot(1,1,1)
omega = np.fft.fft2(scalar_store[0])
field = ax.pcolormesh(np.fft.fftshift(freq),np.fft.fftshift(freq),log(abs(np.fft.fftshift(omega))),cmap=cmap)
flat=log(abs(fftshift(omega))).flatten()
flat.sort()
field.set_clim(flat[-2]-.1,flat[-2])
ax.set_ylim(-10,10)
ax.set_xlim(-10,10)
def xy(r,phi):
    return r*np.cos(phi), r*np.sin(phi)

phis=np.arange(0,6.28,0.01)

#Input the norm of the most unstable wave number using the stability code
r = 5.44
ax.plot( *xy(r,phis), c='r',ls='-' )

fig.colorbar(field)

plt.suptitle(r'$d_1 = {0},d_2={1}$'.format(Swimmers.d1, Swimmers.d2), fontsize = 10)

def initit():
    return field

def animate(k):
    omega = fft2(scalar_store[k])
    arr = log(abs(fftshift(omega)))
    arr = arr[:-1, :-1]
    field.set_array(arr.ravel())
    flat=log(abs(fftshift(omega))).flatten()
    flat.sort()
    field.set_clim(flat[-2]-.21,flat[-2])
    plt.title(r'T = {0}'.format(round(k*Swimmers.k,2)), fontsize = 15)
    
    return field
    
anim = matplotlib.animation.FuncAnimation(fig,animate,frames=range(0,len(scalar_store),1),
                                          interval=200,blit=False,repeat=False)

# Uncomment if you want to save it to a file.  Requires mencoder or ffmpeg or some writer utility to generate the file.
#anim.save('High_Wave_NumberAnim_d102_d250_Slow.mp4', writer='ffmpeg')
plt.show()
```

```{python}

```
