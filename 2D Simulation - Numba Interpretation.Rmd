---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.2
  kernelspec:
    display_name: Python [Root]
    language: python
    name: Python [Root]
---

```{python}
from scipy import *
import numpy as np
import matplotlib
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
import PlanktonSignaling.basicsForNumba as PS
import PlanktonSignaling.Deposition as DP
import profile
import copy
import time
import scipy.sparse as sp

from scipy.interpolate import RectBivariateSpline,griddata
from scipy.sparse.linalg import spsolve
from scipy.linalg import solve
from scipy.sparse import linalg as sla
from numpy.random import rand, uniform
from scipy import sparse
from numba import int32, float32, float64, int64, njit, prange
from numpy import exp
```

```{python}
def initial_conditions(x,y):
    return(0*x + 0.01)

def scalarInterp(x_periodic,y_periodic,scalar_periodic,pos):
    bspline = RectBivariateSpline(x_periodic,y_periodic,scalar_periodic)
    return(bspline.ev(pos[:,1],pos[:,0]))

def scalarGrad(L,x_periodic,y_periodic,scalar_periodic,xp,dx=1.0e-4):
    dx = dx*L
    bspline = RectBivariateSpline(x_periodic,y_periodic,scalar_periodic)
    p = np.array([np.mod(xp + np.array([dx,0]),L),np.mod(xp - np.array([dx,0]),L),np.mod(xp + np.array([0,dx]),L),
                                  np.mod(xp - np.array([0,dx]),L)])

    dp = bspline.ev(p[:,:,1],p[:,:,0])

    diffs = np.array([dp[0]-dp[1],dp[2]-dp[3]])/2/dx
    diffs = diffs.T
    return(diffs)

@njit
def RT(k,delta,L,pos,vel,c,grad_c):
# Actually, I need to do this as tumble and run, TR.
    for j in range(len(pos)):
        Dot = np.dot(vel[j],grad_c[j])
        alpha = 1/np.sqrt(delta**2 + Dot**2)
        if (rand() < k*0.5*(1-alpha*Dot)):
            th = rand()*2*pi
            vel[j] = np.array([np.cos(th),np.sin(th)])
    for j in range(len(pos)):
        pos[j] += k*vel[j]
        pos[j] = np.mod(pos[j],L)
    return(pos,vel)

@njit(parallel=True) 
def Update(N,L,k,Std,num,depStr,pos,xm,ym,intDelta,meshsize,boundaryCutoff):    
    
    f = np.zeros((N,N),dtype=float32)
    #f = np.zeros((N,N))
    for i in prange(num):
        Str = depStr[i]
        p = pos[i]
        A, B, C, D = 0,0,0,0
        centerX = int((meshsize-1)*p[0]/L+0.5)
        centerY = int((meshsize-1)*p[1]/L+0.5)
        lowerX      = max(0,centerX-intDelta)
        lowerXplus  = max(0,centerX-intDelta + (meshsize-1))
        lowerXminus = max(0,centerX-intDelta - (meshsize-1))
        upperX      = min(meshsize,centerX+intDelta)
        upperXplus  = min(meshsize,centerX+intDelta + (meshsize-1))
        upperXminus = min(meshsize,centerX+intDelta - (meshsize-1))
        lowerY      = max(0,centerY-intDelta)
        lowerYplus  = max(0,centerY-intDelta + (meshsize-1))
        lowerYminus = max(0,centerY-intDelta - (meshsize-1))
        upperY      = min(meshsize,centerY+intDelta)
        upperYplus  = min(meshsize,centerY+intDelta + (meshsize-1))
        upperYminus = min(meshsize,centerY+intDelta - (meshsize-1))
        sliceX = slice(lowerX,upperX+1)
        sliceY = slice(lowerY,upperY+1)
        f[sliceY,sliceX] += Str*(1/(4*pi*Std))*exp(-((xm[sliceY,sliceX]-p[0])**2
                               +(ym[sliceY,sliceX]-p[1])**2)/4/Std)
        if ((p[0])**2<boundaryCutoff):
            sliceX = slice(lowerXplus,upperXplus+1)
            sliceY = slice(lowerY,upperY+1)
            f[sliceY,sliceX] += Str*(1/(4*pi*Std))*exp(-((xm[sliceY,sliceX]-p[0]-L)**2
                                           +(ym[sliceY,sliceX]-p[1])**2)/4/Std)
            A = 1
        if ((p[0]-L)**2<boundaryCutoff):
            sliceX = slice(lowerXminus,upperXminus+1)
            sliceY = slice(lowerY,upperY+1)
            f[sliceY,sliceX] += Str*(1/(4*pi*Std))*exp(-((xm[sliceY,sliceX]-p[0]+L)**2
                                       +(ym[sliceY,sliceX]-p[1])**2)/4/Std)
            B = 1
        if ((p[1])**2<boundaryCutoff):
            sliceX = slice(lowerX,upperX+1)
            sliceY = slice(lowerYplus,upperYplus+1)
            f[sliceY,sliceX] += Str*(1/(4*pi*Std))*exp(-((xm[sliceY,sliceX]-p[0])**2
                                    +(ym[sliceY,sliceX]-p[1]-L)**2)/4/Std)
            C = 1
        if ((p[1]-L)**2<boundaryCutoff):
            sliceX = slice(lowerX,upperX+1)
            sliceY = slice(lowerYminus,upperYminus+1)
            f[sliceY,sliceX] += Str*(1/(4*pi*Std))*exp(-((xm[sliceY,sliceX]-p[0])**2
                                +(ym[sliceY,sliceX]-p[1]+L)**2)/4/Std)
            D = 1
        if (A == 1 and C == 1): #Plankton in Lower Left Corner
            sliceX = slice(lowerXplus,upperXplus+1)
            sliceY = slice(lowerYplus,upperYplus+1)
            f[sliceY,sliceX] += Str*(1/(4*pi*Std))*exp(-((xm[sliceY,sliceX]-p[0]-L)**2
                                 +(ym[sliceY,sliceX]-p[1]-L)**2)/4/Std)
        if (A == 1 and D == 1): #Plankton in Lower Left Corner
            sliceX = slice(lowerXplus,upperXplus+1)
            sliceY = slice(lowerYminus,upperYminus+1)
            f[sliceY,sliceX] += Str*(1/(4*pi*Std))*exp(-((xm[sliceY,sliceX]-p[0]-L)**2
                                   +(ym[sliceY,sliceX]-p[1]+L)**2)/4/Std)
        elif (B == 1 and C == 1): #Plankton in Upper Right Corner
            sliceX = slice(lowerXminus,upperXminus+1)
            sliceY = slice(lowerYplus,upperYplus+1)
            f[sliceY,sliceX] += Str*(1/(4*pi*Std))*exp(-((xm[sliceY,sliceX]-p[0]+L)**2
                                    +(ym[sliceY,sliceX]-p[1]-L)**2)/4/Std)
        elif (B == 1 and D == 1): #Plankton in Lower Right Corner
            sliceX = slice(lowerXminus,upperXminus+1)
            sliceY = slice(lowerYminus,upperYminus+1)
            f[sliceY,sliceX] += Str*(1/(4*pi*Std))*exp(-((xm[sliceY,sliceX]-p[0]+L)**2
                                    +(ym[sliceY,sliceX]-p[1]+L)**2)/4/Std)

    f = f.reshape((N**2,))
    return(f)
```

```{python}
meshsize = 100  #Chemical Mesh size
numb = 40**2  #Number of plankton in simulation
LL = 10 #Length of domain [0,L] x [0,L]
dt = 0.02 #Time-stepping size
TotalTime = 300 #Total time 
simTime = int(TotalTime/dt) #Number of timesteps in order to achieve total Time 
j = 1

if (j == 1):
    SM = PS.Plankton(DP.constantDep,d1=.1,d2=4,N = meshsize,depMaxStr=.01,
                            Const=3,L=LL,k=dt,delta=1e-3,depThreshold=0.012, 
                        depTransWidth=0.008, num = numb, c0=0.01)
if (j == 2):
    SM = PS.Plankton(DP.atanDep,d1=.1,d2=4,N = meshsize,depMaxStr=.01,
                           Const=3,L=LL,k=dt,delta=1e-3,depThreshold=0.012, 
                          depTransWidth=0.0007, num = numb, c0=0.01)
    
if (j == 3):
    SM = PS.Plankton(DP.linAtanDep,d1=.1,d2=4,N = meshsize,depMaxStr=.01,
                           Const=3,L=LL,k=dt,delta=1e-3,depThreshold=0.012, 
                           depTransWidth=0.008, num = numb, c0=0.01)
    
    
SM.SetIC(initial_conditions)

lenn = int(np.sqrt(numb))
pos = np.zeros((1,2))
vel = np.zeros((1,2))

#Place plankton down uniformly throughout the domain and give each a direction to travel initially
for l in range(0,lenn):
    for k in range(0,lenn):
        pos = np.append(pos,[np.array([np.mod(k*(SM.L*1/(lenn)) + 0.5*(SM.L*1/(lenn)),SM.L),
            np.mod(l*(SM.L*1/(lenn)) + 0.5*(SM.L*1/(lenn)),SM.L)])],axis=0)
        th  = rand()*2*pi
        vel = np.append(vel,[np.array([np.cos(th),np.sin(th)])],axis=0)
        
pos = np.delete(pos,0,0)
vel = np.delete(vel,0,0)
pos_store = list([pos[:,:]])
pos_store = list([np.array(pos)])
scalar_store = list([SM.Meshed()])

CHEM = np.zeros((simTime,meshsize,meshsize))
POS = np.zeros((simTime,numb,2))
CHEM[0,:,:] = scalar_store[0] #preallocate the chemical 
POS[0,:,:] = pos_store[0] #preallocate the plankton
MaxChem = np.zeros(simTime)
MinChem = np.zeros(simTime)
TotalChem = np.zeros(simTime)

#Set parameters
boundaryCutoff = 64*SM.depVar
intDelta = int((SM.N - 1)*8*np.sqrt(SM.depVar)/SM.L+0.5)
Std = SM.depVar
meshsize = SM.N
PlankDensity = SM.density*SM.L**2/SM.num

#Use LU decomposition
LU = sla.splu(SM.M1.tocsc())

#Set arrays to keep track of time
Time1 = np.zeros(simTime-1)
Time2 = np.zeros(simTime-1)
Time3 = np.zeros(simTime-1)
Time4 = np.zeros(simTime-1)
Time5 = np.zeros(simTime-1)
Time = np.zeros(simTime-1)
```

```{python}
for k in range(1,simTime):
    start = time.time()

    start1 = time.time()
    SM.BuildPeriodic()
    c = scalarInterp(SM.x_periodic,SM.y_periodic,SM.scalar_periodic,pos)
    SM.BuildPeriodic()
    grad_c = scalarGrad(SM.L,SM.x_periodic,SM.y_periodic,SM.scalar_periodic,pos)
    end1 = time.time()

    start2 = time.time()
    pos,vel = RT(SM.k,SM.delta,SM.L,pos,vel,c,grad_c)
    end2 = time.time()

    start3 = time.time()
    depStr = SM.depFcn(c,SM.depMaxStr,SM.depThreshold,SM.depTransWidth)
    end3 = time.time()

    start4 = time.time()
    f = Update(SM.N,SM.L,SM.k,Std,SM.num,depStr,pos,SM.xm,SM.ym,intDelta,meshsize,boundaryCutoff)
    end4 = time.time()

    start5 = time.time()
    SM.scalar = LU.solve(SM.M2.dot(SM.scalar)+SM.k*(PlankDensity)*f)
    end5 = time.time()

    end = time.time()

    Time1[k-1] = end1-start1
    Time2[k-1] = end2-start2
    Time3[k-1] = end3-start3
    Time4[k-1] = end4-start4
    Time5[k-1] = end5-start5

    Time[k-1] = end-start

    CHEM[k,:,:] = SM.Meshed()
    POS[k,:,:] = pos
    MaxChem[k] = max(CHEM[1].flatten())
    MinChem[k] = min(CHEM[1].flatten())
    TotalChem[k] = np.sum(CHEM[1].flatten())*(LL/meshsize)**2
```
